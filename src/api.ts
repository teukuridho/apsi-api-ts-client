// tslint:disable
/**
 * APSI API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import { Configuration } from "./configuration";
const isomorphicFetch = fetch;

const BASE_PATH = "http://localhost:8080/api".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name = "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface ApiResponseBookCategoryDto
 */
export interface ApiResponseBookCategoryDto {
    /**
     * 
     * @type {string}
     * @memberof ApiResponseBookCategoryDto
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseBookCategoryDto
     */
    error?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiResponseBookCategoryDto
     */
    statusCode: number;
    /**
     * 
     * @type {BookCategoryDto}
     * @memberof ApiResponseBookCategoryDto
     */
    data?: BookCategoryDto;
}
/**
 * 
 * @export
 * @interface ApiResponseBookDto
 */
export interface ApiResponseBookDto {
    /**
     * 
     * @type {string}
     * @memberof ApiResponseBookDto
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseBookDto
     */
    error?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiResponseBookDto
     */
    statusCode: number;
    /**
     * 
     * @type {BookDto}
     * @memberof ApiResponseBookDto
     */
    data?: BookDto;
}
/**
 * 
 * @export
 * @interface ApiResponseCheckInResponse
 */
export interface ApiResponseCheckInResponse {
    /**
     * 
     * @type {string}
     * @memberof ApiResponseCheckInResponse
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseCheckInResponse
     */
    error?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiResponseCheckInResponse
     */
    statusCode: number;
    /**
     * 
     * @type {CheckInResponse}
     * @memberof ApiResponseCheckInResponse
     */
    data?: CheckInResponse;
}
/**
 * 
 * @export
 * @interface ApiResponseCheckOutResponse
 */
export interface ApiResponseCheckOutResponse {
    /**
     * 
     * @type {string}
     * @memberof ApiResponseCheckOutResponse
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseCheckOutResponse
     */
    error?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiResponseCheckOutResponse
     */
    statusCode: number;
    /**
     * 
     * @type {CheckOutResponse}
     * @memberof ApiResponseCheckOutResponse
     */
    data?: CheckOutResponse;
}
/**
 * 
 * @export
 * @interface ApiResponseClassRoomDto
 */
export interface ApiResponseClassRoomDto {
    /**
     * 
     * @type {string}
     * @memberof ApiResponseClassRoomDto
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseClassRoomDto
     */
    error?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiResponseClassRoomDto
     */
    statusCode: number;
    /**
     * 
     * @type {ClassRoomDto}
     * @memberof ApiResponseClassRoomDto
     */
    data?: ClassRoomDto;
}
/**
 * 
 * @export
 * @interface ApiResponseLoginResponse
 */
export interface ApiResponseLoginResponse {
    /**
     * 
     * @type {string}
     * @memberof ApiResponseLoginResponse
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseLoginResponse
     */
    error?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiResponseLoginResponse
     */
    statusCode: number;
    /**
     * 
     * @type {LoginResponse}
     * @memberof ApiResponseLoginResponse
     */
    data?: LoginResponse;
}
/**
 * 
 * @export
 * @interface ApiResponsePageInfoResponseBookCategoryDto
 */
export interface ApiResponsePageInfoResponseBookCategoryDto {
    /**
     * 
     * @type {string}
     * @memberof ApiResponsePageInfoResponseBookCategoryDto
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiResponsePageInfoResponseBookCategoryDto
     */
    error?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiResponsePageInfoResponseBookCategoryDto
     */
    statusCode: number;
    /**
     * 
     * @type {PageInfoResponseBookCategoryDto}
     * @memberof ApiResponsePageInfoResponseBookCategoryDto
     */
    data?: PageInfoResponseBookCategoryDto;
}
/**
 * 
 * @export
 * @interface ApiResponsePageInfoResponseBookDto
 */
export interface ApiResponsePageInfoResponseBookDto {
    /**
     * 
     * @type {string}
     * @memberof ApiResponsePageInfoResponseBookDto
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiResponsePageInfoResponseBookDto
     */
    error?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiResponsePageInfoResponseBookDto
     */
    statusCode: number;
    /**
     * 
     * @type {PageInfoResponseBookDto}
     * @memberof ApiResponsePageInfoResponseBookDto
     */
    data?: PageInfoResponseBookDto;
}
/**
 * 
 * @export
 * @interface ApiResponsePageInfoResponseClassRoomDto
 */
export interface ApiResponsePageInfoResponseClassRoomDto {
    /**
     * 
     * @type {string}
     * @memberof ApiResponsePageInfoResponseClassRoomDto
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiResponsePageInfoResponseClassRoomDto
     */
    error?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiResponsePageInfoResponseClassRoomDto
     */
    statusCode: number;
    /**
     * 
     * @type {PageInfoResponseClassRoomDto}
     * @memberof ApiResponsePageInfoResponseClassRoomDto
     */
    data?: PageInfoResponseClassRoomDto;
}
/**
 * 
 * @export
 * @interface ApiResponsePageInfoResponseSubjectDto
 */
export interface ApiResponsePageInfoResponseSubjectDto {
    /**
     * 
     * @type {string}
     * @memberof ApiResponsePageInfoResponseSubjectDto
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiResponsePageInfoResponseSubjectDto
     */
    error?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiResponsePageInfoResponseSubjectDto
     */
    statusCode: number;
    /**
     * 
     * @type {PageInfoResponseSubjectDto}
     * @memberof ApiResponsePageInfoResponseSubjectDto
     */
    data?: PageInfoResponseSubjectDto;
}
/**
 * 
 * @export
 * @interface ApiResponseScheduleDto
 */
export interface ApiResponseScheduleDto {
    /**
     * 
     * @type {string}
     * @memberof ApiResponseScheduleDto
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseScheduleDto
     */
    error?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiResponseScheduleDto
     */
    statusCode: number;
    /**
     * 
     * @type {ScheduleDto}
     * @memberof ApiResponseScheduleDto
     */
    data?: ScheduleDto;
}
/**
 * 
 * @export
 * @interface ApiResponseString
 */
export interface ApiResponseString {
    /**
     * 
     * @type {string}
     * @memberof ApiResponseString
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseString
     */
    error?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiResponseString
     */
    statusCode: number;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseString
     */
    data?: string;
}
/**
 * 
 * @export
 * @interface ApiResponseStudyMaterialDto
 */
export interface ApiResponseStudyMaterialDto {
    /**
     * 
     * @type {string}
     * @memberof ApiResponseStudyMaterialDto
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseStudyMaterialDto
     */
    error?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiResponseStudyMaterialDto
     */
    statusCode: number;
    /**
     * 
     * @type {StudyMaterialDto}
     * @memberof ApiResponseStudyMaterialDto
     */
    data?: StudyMaterialDto;
}
/**
 * 
 * @export
 * @interface ApiResponseSubjectDto
 */
export interface ApiResponseSubjectDto {
    /**
     * 
     * @type {string}
     * @memberof ApiResponseSubjectDto
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseSubjectDto
     */
    error?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiResponseSubjectDto
     */
    statusCode: number;
    /**
     * 
     * @type {SubjectDto}
     * @memberof ApiResponseSubjectDto
     */
    data?: SubjectDto;
}
/**
 * 
 * @export
 * @interface ApiResponseVoid
 */
export interface ApiResponseVoid {
    /**
     * 
     * @type {string}
     * @memberof ApiResponseVoid
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiResponseVoid
     */
    error?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiResponseVoid
     */
    statusCode: number;
    /**
     * 
     * @type {any}
     * @memberof ApiResponseVoid
     */
    data?: any;
}
/**
 * 
 * @export
 * @interface BookCategoryDto
 */
export interface BookCategoryDto {
    /**
     * 
     * @type {number}
     * @memberof BookCategoryDto
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof BookCategoryDto
     */
    name: string;
}
/**
 * 
 * @export
 * @interface BookDto
 */
export interface BookDto {
    /**
     * 
     * @type {number}
     * @memberof BookDto
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof BookDto
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof BookDto
     */
    author?: string;
    /**
     * 
     * @type {string}
     * @memberof BookDto
     */
    isbn: string;
    /**
     * 
     * @type {string}
     * @memberof BookDto
     */
    publisher?: string;
    /**
     * 
     * @type {string}
     * @memberof BookDto
     */
    language?: string;
    /**
     * 
     * @type {Array<BookCategoryDto>}
     * @memberof BookDto
     */
    categories: Array<BookCategoryDto>;
    /**
     * 
     * @type {string}
     * @memberof BookDto
     */
    file?: string;
}
/**
 * 
 * @export
 * @interface ChangePasswordRequest
 */
export interface ChangePasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordRequest
     */
    oldPassword: string;
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordRequest
     */
    newPassword: string;
}
/**
 * 
 * @export
 * @interface CheckInResponse
 */
export interface CheckInResponse {
    /**
     * 
     * @type {boolean}
     * @memberof CheckInResponse
     */
    late?: boolean;
}
/**
 * 
 * @export
 * @interface CheckOutResponse
 */
export interface CheckOutResponse {
    /**
     * 
     * @type {boolean}
     * @memberof CheckOutResponse
     */
    earlyLeave?: boolean;
}
/**
 * 
 * @export
 * @interface ClassRoomDto
 */
export interface ClassRoomDto {
    /**
     * 
     * @type {number}
     * @memberof ClassRoomDto
     */
    id: number;
    /**
     * 
     * @type {SchoolDto}
     * @memberof ClassRoomDto
     */
    school: SchoolDto;
    /**
     * 
     * @type {string}
     * @memberof ClassRoomDto
     */
    name: string;
    /**
     * 
     * @type {TeacherDto}
     * @memberof ClassRoomDto
     */
    teacher: TeacherDto;
    /**
     * 
     * @type {Array<number>}
     * @memberof ClassRoomDto
     */
    studentIds: Array<number>;
}
/**
 * 
 * @export
 * @interface CreateBookCategoryRequest
 */
export interface CreateBookCategoryRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateBookCategoryRequest
     */
    name: string;
}
/**
 * 
 * @export
 * @interface CreateBookRequest
 */
export interface CreateBookRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateBookRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof CreateBookRequest
     */
    author: string;
    /**
     * 
     * @type {string}
     * @memberof CreateBookRequest
     */
    isbn: string;
    /**
     * 
     * @type {string}
     * @memberof CreateBookRequest
     */
    publisher: string;
    /**
     * 
     * @type {string}
     * @memberof CreateBookRequest
     */
    language: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof CreateBookRequest
     */
    categoryIds: Array<number>;
    /**
     * 
     * @type {Blob}
     * @memberof CreateBookRequest
     */
    file?: Blob;
}
/**
 * 
 * @export
 * @interface CreateClassRoomRequest
 */
export interface CreateClassRoomRequest {
    /**
     * 
     * @type {number}
     * @memberof CreateClassRoomRequest
     */
    schoolId?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateClassRoomRequest
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof CreateClassRoomRequest
     */
    teacherId: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof CreateClassRoomRequest
     */
    studentIds: Array<number>;
}
/**
 * 
 * @export
 * @interface CreateScheduleRequest
 */
export interface CreateScheduleRequest {
    /**
     * 
     * @type {number}
     * @memberof CreateScheduleRequest
     */
    schoolId?: number;
    /**
     * 
     * @type {number}
     * @memberof CreateScheduleRequest
     */
    classRoomId: number;
    /**
     * 
     * @type {number}
     * @memberof CreateScheduleRequest
     */
    teacherId: number;
    /**
     * 
     * @type {number}
     * @memberof CreateScheduleRequest
     */
    subjectId: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof CreateScheduleRequest
     */
    studentIds: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof CreateScheduleRequest
     */
    startTime: string;
    /**
     * 
     * @type {string}
     * @memberof CreateScheduleRequest
     */
    endTime: string;
    /**
     * 
     * @type {string}
     * @memberof CreateScheduleRequest
     */
    date: string;
}
/**
 * 
 * @export
 * @interface CreateStudyMaterialRequest
 */
export interface CreateStudyMaterialRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateStudyMaterialRequest
     */
    title?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateStudyMaterialRequest
     */
    subjectId: number;
    /**
     * 
     * @type {number}
     * @memberof CreateStudyMaterialRequest
     */
    teacherId: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof CreateStudyMaterialRequest
     */
    bookIds?: Array<number>;
    /**
     * 
     * @type {Array<Blob>}
     * @memberof CreateStudyMaterialRequest
     */
    files?: Array<Blob>;
}
/**
 * 
 * @export
 * @interface CreateSubjectRequest
 */
export interface CreateSubjectRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateSubjectRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateSubjectRequest
     */
    gradeLevel: string;
    /**
     * 
     * @type {number}
     * @memberof CreateSubjectRequest
     */
    schoolId: number;
}
/**
 * 
 * @export
 * @interface GetBookCategoriesFilter
 */
export interface GetBookCategoriesFilter {
    /**
     * 
     * @type {string}
     * @memberof GetBookCategoriesFilter
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface GetBooksFilter
 */
export interface GetBooksFilter {
    /**
     * 
     * @type {string}
     * @memberof GetBooksFilter
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof GetBooksFilter
     */
    author?: string;
    /**
     * 
     * @type {string}
     * @memberof GetBooksFilter
     */
    publisher?: string;
    /**
     * 
     * @type {string}
     * @memberof GetBooksFilter
     */
    isbn?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof GetBooksFilter
     */
    categoryIds?: Array<number>;
}
/**
 * 
 * @export
 * @interface GetClassRoomsFilter
 */
export interface GetClassRoomsFilter {
    /**
     * 
     * @type {string}
     * @memberof GetClassRoomsFilter
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof GetClassRoomsFilter
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof GetClassRoomsFilter
     */
    homeroomTeacherId?: number;
}
/**
 * 
 * @export
 * @interface GetClassRoomsRequest
 */
export interface GetClassRoomsRequest {
    /**
     * 
     * @type {number}
     * @memberof GetClassRoomsRequest
     */
    schoolId?: number;
}
/**
 * 
 * @export
 * @interface GetSubjectsFilter
 */
export interface GetSubjectsFilter {
    /**
     * 
     * @type {string}
     * @memberof GetSubjectsFilter
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof GetSubjectsFilter
     */
    gradeLevel?: string;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    password: string;
}
/**
 * 
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    token: string;
    /**
     * 
     * @type {UserDto}
     * @memberof LoginResponse
     */
    user: UserDto;
}
/**
 * 
 * @export
 * @interface PageInfoResponseBookCategoryDto
 */
export interface PageInfoResponseBookCategoryDto {
    /**
     * 
     * @type {number}
     * @memberof PageInfoResponseBookCategoryDto
     */
    size?: number;
    /**
     * 
     * @type {number}
     * @memberof PageInfoResponseBookCategoryDto
     */
    number?: number;
    /**
     * 
     * @type {number}
     * @memberof PageInfoResponseBookCategoryDto
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageInfoResponseBookCategoryDto
     */
    totalPages?: number;
    /**
     * 
     * @type {Array<BookCategoryDto>}
     * @memberof PageInfoResponseBookCategoryDto
     */
    content?: Array<BookCategoryDto>;
}
/**
 * 
 * @export
 * @interface PageInfoResponseBookDto
 */
export interface PageInfoResponseBookDto {
    /**
     * 
     * @type {number}
     * @memberof PageInfoResponseBookDto
     */
    size?: number;
    /**
     * 
     * @type {number}
     * @memberof PageInfoResponseBookDto
     */
    number?: number;
    /**
     * 
     * @type {number}
     * @memberof PageInfoResponseBookDto
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageInfoResponseBookDto
     */
    totalPages?: number;
    /**
     * 
     * @type {Array<BookDto>}
     * @memberof PageInfoResponseBookDto
     */
    content?: Array<BookDto>;
}
/**
 * 
 * @export
 * @interface PageInfoResponseClassRoomDto
 */
export interface PageInfoResponseClassRoomDto {
    /**
     * 
     * @type {number}
     * @memberof PageInfoResponseClassRoomDto
     */
    size?: number;
    /**
     * 
     * @type {number}
     * @memberof PageInfoResponseClassRoomDto
     */
    number?: number;
    /**
     * 
     * @type {number}
     * @memberof PageInfoResponseClassRoomDto
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageInfoResponseClassRoomDto
     */
    totalPages?: number;
    /**
     * 
     * @type {Array<ClassRoomDto>}
     * @memberof PageInfoResponseClassRoomDto
     */
    content?: Array<ClassRoomDto>;
}
/**
 * 
 * @export
 * @interface PageInfoResponseSubjectDto
 */
export interface PageInfoResponseSubjectDto {
    /**
     * 
     * @type {number}
     * @memberof PageInfoResponseSubjectDto
     */
    size?: number;
    /**
     * 
     * @type {number}
     * @memberof PageInfoResponseSubjectDto
     */
    number?: number;
    /**
     * 
     * @type {number}
     * @memberof PageInfoResponseSubjectDto
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageInfoResponseSubjectDto
     */
    totalPages?: number;
    /**
     * 
     * @type {Array<SubjectDto>}
     * @memberof PageInfoResponseSubjectDto
     */
    content?: Array<SubjectDto>;
}
/**
 * 
 * @export
 * @interface Pageable
 */
export interface Pageable {
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    size?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Pageable
     */
    sort?: Array<string>;
}
/**
 * 
 * @export
 * @interface RoleDto
 */
export interface RoleDto {
    /**
     * 
     * @type {number}
     * @memberof RoleDto
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof RoleDto
     */
    name: string;
}
/**
 * 
 * @export
 * @interface ScheduleDto
 */
export interface ScheduleDto {
    /**
     * 
     * @type {number}
     * @memberof ScheduleDto
     */
    id: number;
    /**
     * 
     * @type {SchoolDto}
     * @memberof ScheduleDto
     */
    school: SchoolDto;
    /**
     * 
     * @type {string}
     * @memberof ScheduleDto
     */
    classRoomName: string;
    /**
     * 
     * @type {TeacherDto}
     * @memberof ScheduleDto
     */
    teacher: TeacherDto;
    /**
     * 
     * @type {SubjectDto}
     * @memberof ScheduleDto
     */
    subject: SubjectDto;
    /**
     * 
     * @type {Array<number>}
     * @memberof ScheduleDto
     */
    studentIds: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof ScheduleDto
     */
    startTime: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleDto
     */
    endTime: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleDto
     */
    date?: string;
}
/**
 * 
 * @export
 * @interface SchoolDto
 */
export interface SchoolDto {
    /**
     * 
     * @type {number}
     * @memberof SchoolDto
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof SchoolDto
     */
    name: string;
}
/**
 * 
 * @export
 * @interface StudyMaterialDto
 */
export interface StudyMaterialDto {
    /**
     * 
     * @type {number}
     * @memberof StudyMaterialDto
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof StudyMaterialDto
     */
    title: string;
    /**
     * 
     * @type {TeacherDto}
     * @memberof StudyMaterialDto
     */
    teacher: TeacherDto;
    /**
     * 
     * @type {SubjectDto}
     * @memberof StudyMaterialDto
     */
    subject: SubjectDto;
    /**
     * 
     * @type {Array<BookDto>}
     * @memberof StudyMaterialDto
     */
    books: Array<BookDto>;
    /**
     * 
     * @type {Array<string>}
     * @memberof StudyMaterialDto
     */
    files: Array<string>;
}
/**
 * 
 * @export
 * @interface SubjectDto
 */
export interface SubjectDto {
    /**
     * 
     * @type {number}
     * @memberof SubjectDto
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof SubjectDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof SubjectDto
     */
    gradeLevel?: string;
}
/**
 * 
 * @export
 * @interface TeacherDto
 */
export interface TeacherDto {
    /**
     * 
     * @type {number}
     * @memberof TeacherDto
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof TeacherDto
     */
    name: string;
}
/**
 * 
 * @export
 * @interface UpdateBookCategoryRequest
 */
export interface UpdateBookCategoryRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateBookCategoryRequest
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface UpdateBookRequest
 */
export interface UpdateBookRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateBookRequest
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBookRequest
     */
    author?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBookRequest
     */
    isbn?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBookRequest
     */
    publisher?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBookRequest
     */
    language?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof UpdateBookRequest
     */
    categoryIds?: Array<number>;
    /**
     * 
     * @type {Blob}
     * @memberof UpdateBookRequest
     */
    file?: Blob;
}
/**
 * 
 * @export
 * @interface UpdateClassRoomRequest
 */
export interface UpdateClassRoomRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateClassRoomRequest
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateClassRoomRequest
     */
    teacherId?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof UpdateClassRoomRequest
     */
    studentIds?: Array<number>;
}
/**
 * 
 * @export
 * @interface UpdateScheduleRequest
 */
export interface UpdateScheduleRequest {
    /**
     * 
     * @type {number}
     * @memberof UpdateScheduleRequest
     */
    classRoomId?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateScheduleRequest
     */
    teacherId?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateScheduleRequest
     */
    subjectId?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof UpdateScheduleRequest
     */
    studentIds?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof UpdateScheduleRequest
     */
    startTime?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateScheduleRequest
     */
    endTime?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateScheduleRequest
     */
    date?: string;
}
/**
 * 
 * @export
 * @interface UpdateStudyMaterialRequest
 */
export interface UpdateStudyMaterialRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateStudyMaterialRequest
     */
    title?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateStudyMaterialRequest
     */
    subjectId?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateStudyMaterialRequest
     */
    teacherId?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof UpdateStudyMaterialRequest
     */
    bookIds?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof UpdateStudyMaterialRequest
     */
    deletedFileIds?: Array<number>;
    /**
     * 
     * @type {Array<Blob>}
     * @memberof UpdateStudyMaterialRequest
     */
    newFiles?: Array<Blob>;
}
/**
 * 
 * @export
 * @interface UpdateSubjectRequest
 */
export interface UpdateSubjectRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateSubjectRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSubjectRequest
     */
    gradeLevel?: string;
}
/**
 * 
 * @export
 * @interface UserDto
 */
export interface UserDto {
    /**
     * 
     * @type {number}
     * @memberof UserDto
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    username: string;
    /**
     * 
     * @type {Array<RoleDto>}
     * @memberof UserDto
     */
    roles: Array<RoleDto>;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    gender?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    birthday?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    phone?: string;
    /**
     * 
     * @type {SchoolDto}
     * @memberof UserDto
     */
    school?: SchoolDto;
}
/**
 * AttendanceApi - fetch parameter creator
 * @export
 */
export const AttendanceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Check-in as a student
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkIn(options: any = {}): FetchArgs {
            const localVarPath = `/attendance/check-in`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check-out as a student
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkOut(options: any = {}): FetchArgs {
            const localVarPath = `/attendance/check-out`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AttendanceApi - functional programming interface
 * @export
 */
export const AttendanceApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Check-in as a student
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkIn(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponseCheckInResponse> {
            const localVarFetchArgs = AttendanceApiFetchParamCreator(configuration).checkIn(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Check-out as a student
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkOut(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponseCheckOutResponse> {
            const localVarFetchArgs = AttendanceApiFetchParamCreator(configuration).checkOut(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AttendanceApi - factory interface
 * @export
 */
export const AttendanceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Check-in as a student
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkIn(options?: any) {
            return AttendanceApiFp(configuration).checkIn(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check-out as a student
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkOut(options?: any) {
            return AttendanceApiFp(configuration).checkOut(options)(fetch, basePath);
        },
    };
};

/**
 * AttendanceApi - object-oriented interface
 * @export
 * @class AttendanceApi
 * @extends {BaseAPI}
 */
export class AttendanceApi extends BaseAPI {
    /**
     * 
     * @summary Check-in as a student
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttendanceApi
     */
    public checkIn(options?: any) {
        return AttendanceApiFp(this.configuration).checkIn(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Check-out as a student
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttendanceApi
     */
    public checkOut(options?: any) {
        return AttendanceApiFp(this.configuration).checkOut(options)(this.fetch, this.basePath);
    }

}
/**
 * AuthenticationApi - fetch parameter creator
 * @export
 */
export const AuthenticationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Change password
         * @param {ChangePasswordRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(body: ChangePasswordRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling changePassword.');
            }
            const localVarPath = `/auth/password`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ChangePasswordRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login with username and password
         * @param {LoginRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body: LoginRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling login.');
            }
            const localVarPath = `/auth/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LoginRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Change password
         * @param {ChangePasswordRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(body: ChangePasswordRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponseVoid> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).changePassword(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Login with username and password
         * @param {LoginRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body: LoginRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponseLoginResponse> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).login(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Change password
         * @param {ChangePasswordRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(body: ChangePasswordRequest, options?: any) {
            return AuthenticationApiFp(configuration).changePassword(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Login with username and password
         * @param {LoginRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body: LoginRequest, options?: any) {
            return AuthenticationApiFp(configuration).login(body, options)(fetch, basePath);
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * 
     * @summary Change password
     * @param {ChangePasswordRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public changePassword(body: ChangePasswordRequest, options?: any) {
        return AuthenticationApiFp(this.configuration).changePassword(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Login with username and password
     * @param {LoginRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public login(body: LoginRequest, options?: any) {
        return AuthenticationApiFp(this.configuration).login(body, options)(this.fetch, this.basePath);
    }

}
/**
 * BookApi - fetch parameter creator
 * @export
 */
export const BookApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a book
         * @param {string} [title] 
         * @param {string} [author] 
         * @param {string} [isbn] 
         * @param {string} [publisher] 
         * @param {string} [language] 
         * @param {Array<number>} [categoryIds] 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBook(title?: string, author?: string, isbn?: string, publisher?: string, language?: string, categoryIds?: Array<number>, file?: Blob, options: any = {}): FetchArgs {
            const localVarPath = `/books`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication bearerAuth required

            if (title !== undefined) {
                localVarFormParams.set('title', title as any);
            }

            if (author !== undefined) {
                localVarFormParams.set('author', author as any);
            }

            if (isbn !== undefined) {
                localVarFormParams.set('isbn', isbn as any);
            }

            if (publisher !== undefined) {
                localVarFormParams.set('publisher', publisher as any);
            }

            if (language !== undefined) {
                localVarFormParams.set('language', language as any);
            }

            if (categoryIds) {
                categoryIds.forEach((element) => {
                    localVarFormParams.append('categoryIds', element as any);
                })
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a book
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBook(bookId: number, options: any = {}): FetchArgs {
            // verify required parameter 'bookId' is not null or undefined
            if (bookId === null || bookId === undefined) {
                throw new RequiredError('bookId', 'Required parameter bookId was null or undefined when calling deleteBook.');
            }
            const localVarPath = `/books/{bookId}`
                .replace(`{${"bookId"}}`, encodeURIComponent(String(bookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a book by ID
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBook(bookId: number, options: any = {}): FetchArgs {
            // verify required parameter 'bookId' is not null or undefined
            if (bookId === null || bookId === undefined) {
                throw new RequiredError('bookId', 'Required parameter bookId was null or undefined when calling getBook.');
            }
            const localVarPath = `/books/{bookId}`
                .replace(`{${"bookId"}}`, encodeURIComponent(String(bookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download a book
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookFile(bookId: number, options: any = {}): FetchArgs {
            // verify required parameter 'bookId' is not null or undefined
            if (bookId === null || bookId === undefined) {
                throw new RequiredError('bookId', 'Required parameter bookId was null or undefined when calling getBookFile.');
            }
            const localVarPath = `/books/{bookId}/file`
                .replace(`{${"bookId"}}`, encodeURIComponent(String(bookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get books
         * @param {GetBooksFilter} getBooksFilter 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBooks(getBooksFilter: GetBooksFilter, pageable: Pageable, options: any = {}): FetchArgs {
            // verify required parameter 'getBooksFilter' is not null or undefined
            if (getBooksFilter === null || getBooksFilter === undefined) {
                throw new RequiredError('getBooksFilter', 'Required parameter getBooksFilter was null or undefined when calling getBooks.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable', 'Required parameter pageable was null or undefined when calling getBooks.');
            }
            const localVarPath = `/books`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (getBooksFilter !== undefined) {
                localVarQueryParameter['getBooksFilter'] = getBooksFilter;
            }

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a book
         * @param {number} bookId 
         * @param {string} [title] 
         * @param {string} [author] 
         * @param {string} [isbn] 
         * @param {string} [publisher] 
         * @param {string} [language] 
         * @param {Array<number>} [categoryIds] 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBook(bookId: number, title?: string, author?: string, isbn?: string, publisher?: string, language?: string, categoryIds?: Array<number>, file?: Blob, options: any = {}): FetchArgs {
            // verify required parameter 'bookId' is not null or undefined
            if (bookId === null || bookId === undefined) {
                throw new RequiredError('bookId', 'Required parameter bookId was null or undefined when calling updateBook.');
            }
            const localVarPath = `/books/{bookId}`
                .replace(`{${"bookId"}}`, encodeURIComponent(String(bookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication bearerAuth required

            if (title !== undefined) {
                localVarFormParams.set('title', title as any);
            }

            if (author !== undefined) {
                localVarFormParams.set('author', author as any);
            }

            if (isbn !== undefined) {
                localVarFormParams.set('isbn', isbn as any);
            }

            if (publisher !== undefined) {
                localVarFormParams.set('publisher', publisher as any);
            }

            if (language !== undefined) {
                localVarFormParams.set('language', language as any);
            }

            if (categoryIds) {
                categoryIds.forEach((element) => {
                    localVarFormParams.append('categoryIds', element as any);
                })
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BookApi - functional programming interface
 * @export
 */
export const BookApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a book
         * @param {string} [title] 
         * @param {string} [author] 
         * @param {string} [isbn] 
         * @param {string} [publisher] 
         * @param {string} [language] 
         * @param {Array<number>} [categoryIds] 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBook(title?: string, author?: string, isbn?: string, publisher?: string, language?: string, categoryIds?: Array<number>, file?: Blob, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponseBookDto> {
            const localVarFetchArgs = BookApiFetchParamCreator(configuration).createBook(title, author, isbn, publisher, language, categoryIds, file, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete a book
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBook(bookId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponseVoid> {
            const localVarFetchArgs = BookApiFetchParamCreator(configuration).deleteBook(bookId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a book by ID
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBook(bookId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponseBookDto> {
            const localVarFetchArgs = BookApiFetchParamCreator(configuration).getBook(bookId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Download a book
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookFile(bookId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = BookApiFetchParamCreator(configuration).getBookFile(bookId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get books
         * @param {GetBooksFilter} getBooksFilter 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBooks(getBooksFilter: GetBooksFilter, pageable: Pageable, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponsePageInfoResponseBookDto> {
            const localVarFetchArgs = BookApiFetchParamCreator(configuration).getBooks(getBooksFilter, pageable, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update a book
         * @param {number} bookId 
         * @param {string} [title] 
         * @param {string} [author] 
         * @param {string} [isbn] 
         * @param {string} [publisher] 
         * @param {string} [language] 
         * @param {Array<number>} [categoryIds] 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBook(bookId: number, title?: string, author?: string, isbn?: string, publisher?: string, language?: string, categoryIds?: Array<number>, file?: Blob, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponseBookDto> {
            const localVarFetchArgs = BookApiFetchParamCreator(configuration).updateBook(bookId, title, author, isbn, publisher, language, categoryIds, file, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BookApi - factory interface
 * @export
 */
export const BookApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create a book
         * @param {string} [title] 
         * @param {string} [author] 
         * @param {string} [isbn] 
         * @param {string} [publisher] 
         * @param {string} [language] 
         * @param {Array<number>} [categoryIds] 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBook(title?: string, author?: string, isbn?: string, publisher?: string, language?: string, categoryIds?: Array<number>, file?: Blob, options?: any) {
            return BookApiFp(configuration).createBook(title, author, isbn, publisher, language, categoryIds, file, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a book
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBook(bookId: number, options?: any) {
            return BookApiFp(configuration).deleteBook(bookId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a book by ID
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBook(bookId: number, options?: any) {
            return BookApiFp(configuration).getBook(bookId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Download a book
         * @param {number} bookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookFile(bookId: number, options?: any) {
            return BookApiFp(configuration).getBookFile(bookId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get books
         * @param {GetBooksFilter} getBooksFilter 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBooks(getBooksFilter: GetBooksFilter, pageable: Pageable, options?: any) {
            return BookApiFp(configuration).getBooks(getBooksFilter, pageable, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a book
         * @param {number} bookId 
         * @param {string} [title] 
         * @param {string} [author] 
         * @param {string} [isbn] 
         * @param {string} [publisher] 
         * @param {string} [language] 
         * @param {Array<number>} [categoryIds] 
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBook(bookId: number, title?: string, author?: string, isbn?: string, publisher?: string, language?: string, categoryIds?: Array<number>, file?: Blob, options?: any) {
            return BookApiFp(configuration).updateBook(bookId, title, author, isbn, publisher, language, categoryIds, file, options)(fetch, basePath);
        },
    };
};

/**
 * BookApi - object-oriented interface
 * @export
 * @class BookApi
 * @extends {BaseAPI}
 */
export class BookApi extends BaseAPI {
    /**
     * 
     * @summary Create a book
     * @param {string} [title] 
     * @param {string} [author] 
     * @param {string} [isbn] 
     * @param {string} [publisher] 
     * @param {string} [language] 
     * @param {Array<number>} [categoryIds] 
     * @param {Blob} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookApi
     */
    public createBook(title?: string, author?: string, isbn?: string, publisher?: string, language?: string, categoryIds?: Array<number>, file?: Blob, options?: any) {
        return BookApiFp(this.configuration).createBook(title, author, isbn, publisher, language, categoryIds, file, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete a book
     * @param {number} bookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookApi
     */
    public deleteBook(bookId: number, options?: any) {
        return BookApiFp(this.configuration).deleteBook(bookId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a book by ID
     * @param {number} bookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookApi
     */
    public getBook(bookId: number, options?: any) {
        return BookApiFp(this.configuration).getBook(bookId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Download a book
     * @param {number} bookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookApi
     */
    public getBookFile(bookId: number, options?: any) {
        return BookApiFp(this.configuration).getBookFile(bookId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get books
     * @param {GetBooksFilter} getBooksFilter 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookApi
     */
    public getBooks(getBooksFilter: GetBooksFilter, pageable: Pageable, options?: any) {
        return BookApiFp(this.configuration).getBooks(getBooksFilter, pageable, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update a book
     * @param {number} bookId 
     * @param {string} [title] 
     * @param {string} [author] 
     * @param {string} [isbn] 
     * @param {string} [publisher] 
     * @param {string} [language] 
     * @param {Array<number>} [categoryIds] 
     * @param {Blob} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookApi
     */
    public updateBook(bookId: number, title?: string, author?: string, isbn?: string, publisher?: string, language?: string, categoryIds?: Array<number>, file?: Blob, options?: any) {
        return BookApiFp(this.configuration).updateBook(bookId, title, author, isbn, publisher, language, categoryIds, file, options)(this.fetch, this.basePath);
    }

}
/**
 * BookCategoriesApi - fetch parameter creator
 * @export
 */
export const BookCategoriesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a book category
         * @param {CreateBookCategoryRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBookCategory(body: CreateBookCategoryRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling createBookCategory.');
            }
            const localVarPath = `/book_categories`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateBookCategoryRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a book category
         * @param {number} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBookCategory(categoryId: number, options: any = {}): FetchArgs {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId', 'Required parameter categoryId was null or undefined when calling deleteBookCategory.');
            }
            const localVarPath = `/book_categories/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get book categories
         * @param {GetBookCategoriesFilter} getBookCategoriesFilter 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookCategories(getBookCategoriesFilter: GetBookCategoriesFilter, pageable: Pageable, options: any = {}): FetchArgs {
            // verify required parameter 'getBookCategoriesFilter' is not null or undefined
            if (getBookCategoriesFilter === null || getBookCategoriesFilter === undefined) {
                throw new RequiredError('getBookCategoriesFilter', 'Required parameter getBookCategoriesFilter was null or undefined when calling getBookCategories.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable', 'Required parameter pageable was null or undefined when calling getBookCategories.');
            }
            const localVarPath = `/book_categories`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (getBookCategoriesFilter !== undefined) {
                localVarQueryParameter['getBookCategoriesFilter'] = getBookCategoriesFilter;
            }

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a book category by ID
         * @param {number} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookCategory(categoryId: number, options: any = {}): FetchArgs {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId', 'Required parameter categoryId was null or undefined when calling getBookCategory.');
            }
            const localVarPath = `/book_categories/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a book category
         * @param {UpdateBookCategoryRequest} body 
         * @param {number} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBookCategory(body: UpdateBookCategoryRequest, categoryId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling updateBookCategory.');
            }
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId', 'Required parameter categoryId was null or undefined when calling updateBookCategory.');
            }
            const localVarPath = `/book_categories/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateBookCategoryRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BookCategoriesApi - functional programming interface
 * @export
 */
export const BookCategoriesApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a book category
         * @param {CreateBookCategoryRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBookCategory(body: CreateBookCategoryRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponseBookCategoryDto> {
            const localVarFetchArgs = BookCategoriesApiFetchParamCreator(configuration).createBookCategory(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete a book category
         * @param {number} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBookCategory(categoryId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponseVoid> {
            const localVarFetchArgs = BookCategoriesApiFetchParamCreator(configuration).deleteBookCategory(categoryId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get book categories
         * @param {GetBookCategoriesFilter} getBookCategoriesFilter 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookCategories(getBookCategoriesFilter: GetBookCategoriesFilter, pageable: Pageable, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponsePageInfoResponseBookCategoryDto> {
            const localVarFetchArgs = BookCategoriesApiFetchParamCreator(configuration).getBookCategories(getBookCategoriesFilter, pageable, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a book category by ID
         * @param {number} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookCategory(categoryId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponseBookCategoryDto> {
            const localVarFetchArgs = BookCategoriesApiFetchParamCreator(configuration).getBookCategory(categoryId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update a book category
         * @param {UpdateBookCategoryRequest} body 
         * @param {number} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBookCategory(body: UpdateBookCategoryRequest, categoryId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponseBookCategoryDto> {
            const localVarFetchArgs = BookCategoriesApiFetchParamCreator(configuration).updateBookCategory(body, categoryId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BookCategoriesApi - factory interface
 * @export
 */
export const BookCategoriesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create a book category
         * @param {CreateBookCategoryRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBookCategory(body: CreateBookCategoryRequest, options?: any) {
            return BookCategoriesApiFp(configuration).createBookCategory(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a book category
         * @param {number} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBookCategory(categoryId: number, options?: any) {
            return BookCategoriesApiFp(configuration).deleteBookCategory(categoryId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get book categories
         * @param {GetBookCategoriesFilter} getBookCategoriesFilter 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookCategories(getBookCategoriesFilter: GetBookCategoriesFilter, pageable: Pageable, options?: any) {
            return BookCategoriesApiFp(configuration).getBookCategories(getBookCategoriesFilter, pageable, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a book category by ID
         * @param {number} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBookCategory(categoryId: number, options?: any) {
            return BookCategoriesApiFp(configuration).getBookCategory(categoryId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a book category
         * @param {UpdateBookCategoryRequest} body 
         * @param {number} categoryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBookCategory(body: UpdateBookCategoryRequest, categoryId: number, options?: any) {
            return BookCategoriesApiFp(configuration).updateBookCategory(body, categoryId, options)(fetch, basePath);
        },
    };
};

/**
 * BookCategoriesApi - object-oriented interface
 * @export
 * @class BookCategoriesApi
 * @extends {BaseAPI}
 */
export class BookCategoriesApi extends BaseAPI {
    /**
     * 
     * @summary Create a book category
     * @param {CreateBookCategoryRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookCategoriesApi
     */
    public createBookCategory(body: CreateBookCategoryRequest, options?: any) {
        return BookCategoriesApiFp(this.configuration).createBookCategory(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete a book category
     * @param {number} categoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookCategoriesApi
     */
    public deleteBookCategory(categoryId: number, options?: any) {
        return BookCategoriesApiFp(this.configuration).deleteBookCategory(categoryId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get book categories
     * @param {GetBookCategoriesFilter} getBookCategoriesFilter 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookCategoriesApi
     */
    public getBookCategories(getBookCategoriesFilter: GetBookCategoriesFilter, pageable: Pageable, options?: any) {
        return BookCategoriesApiFp(this.configuration).getBookCategories(getBookCategoriesFilter, pageable, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a book category by ID
     * @param {number} categoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookCategoriesApi
     */
    public getBookCategory(categoryId: number, options?: any) {
        return BookCategoriesApiFp(this.configuration).getBookCategory(categoryId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update a book category
     * @param {UpdateBookCategoryRequest} body 
     * @param {number} categoryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookCategoriesApi
     */
    public updateBookCategory(body: UpdateBookCategoryRequest, categoryId: number, options?: any) {
        return BookCategoriesApiFp(this.configuration).updateBookCategory(body, categoryId, options)(this.fetch, this.basePath);
    }

}
/**
 * ClassRoomApi - fetch parameter creator
 * @export
 */
export const ClassRoomApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a classroom
         * @param {CreateClassRoomRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClassRoom(body: CreateClassRoomRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling createClassRoom.');
            }
            const localVarPath = `/classrooms`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateClassRoomRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a classroom
         * @param {number} classRoomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClassRoom(classRoomId: number, options: any = {}): FetchArgs {
            // verify required parameter 'classRoomId' is not null or undefined
            if (classRoomId === null || classRoomId === undefined) {
                throw new RequiredError('classRoomId', 'Required parameter classRoomId was null or undefined when calling deleteClassRoom.');
            }
            const localVarPath = `/classrooms/{classRoomId}`
                .replace(`{${"classRoomId"}}`, encodeURIComponent(String(classRoomId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a classroom by ID
         * @param {number} classRoomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClassRoomById(classRoomId: number, options: any = {}): FetchArgs {
            // verify required parameter 'classRoomId' is not null or undefined
            if (classRoomId === null || classRoomId === undefined) {
                throw new RequiredError('classRoomId', 'Required parameter classRoomId was null or undefined when calling getClassRoomById.');
            }
            const localVarPath = `/classrooms/{classRoomId}`
                .replace(`{${"classRoomId"}}`, encodeURIComponent(String(classRoomId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get classrooms
         * @param {GetClassRoomsFilter} filter 
         * @param {GetClassRoomsRequest} request 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClassrooms(filter: GetClassRoomsFilter, request: GetClassRoomsRequest, pageable: Pageable, options: any = {}): FetchArgs {
            // verify required parameter 'filter' is not null or undefined
            if (filter === null || filter === undefined) {
                throw new RequiredError('filter', 'Required parameter filter was null or undefined when calling getClassrooms.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request', 'Required parameter request was null or undefined when calling getClassrooms.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable', 'Required parameter pageable was null or undefined when calling getClassrooms.');
            }
            const localVarPath = `/classrooms`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (request !== undefined) {
                localVarQueryParameter['request'] = request;
            }

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a classroom
         * @param {UpdateClassRoomRequest} body 
         * @param {number} classRoomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClassRoom(body: UpdateClassRoomRequest, classRoomId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling updateClassRoom.');
            }
            // verify required parameter 'classRoomId' is not null or undefined
            if (classRoomId === null || classRoomId === undefined) {
                throw new RequiredError('classRoomId', 'Required parameter classRoomId was null or undefined when calling updateClassRoom.');
            }
            const localVarPath = `/classrooms/{classRoomId}`
                .replace(`{${"classRoomId"}}`, encodeURIComponent(String(classRoomId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateClassRoomRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClassRoomApi - functional programming interface
 * @export
 */
export const ClassRoomApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a classroom
         * @param {CreateClassRoomRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClassRoom(body: CreateClassRoomRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponseClassRoomDto> {
            const localVarFetchArgs = ClassRoomApiFetchParamCreator(configuration).createClassRoom(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete a classroom
         * @param {number} classRoomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClassRoom(classRoomId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponseVoid> {
            const localVarFetchArgs = ClassRoomApiFetchParamCreator(configuration).deleteClassRoom(classRoomId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a classroom by ID
         * @param {number} classRoomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClassRoomById(classRoomId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponseClassRoomDto> {
            const localVarFetchArgs = ClassRoomApiFetchParamCreator(configuration).getClassRoomById(classRoomId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get classrooms
         * @param {GetClassRoomsFilter} filter 
         * @param {GetClassRoomsRequest} request 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClassrooms(filter: GetClassRoomsFilter, request: GetClassRoomsRequest, pageable: Pageable, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponsePageInfoResponseClassRoomDto> {
            const localVarFetchArgs = ClassRoomApiFetchParamCreator(configuration).getClassrooms(filter, request, pageable, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update a classroom
         * @param {UpdateClassRoomRequest} body 
         * @param {number} classRoomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClassRoom(body: UpdateClassRoomRequest, classRoomId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponseClassRoomDto> {
            const localVarFetchArgs = ClassRoomApiFetchParamCreator(configuration).updateClassRoom(body, classRoomId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ClassRoomApi - factory interface
 * @export
 */
export const ClassRoomApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create a classroom
         * @param {CreateClassRoomRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClassRoom(body: CreateClassRoomRequest, options?: any) {
            return ClassRoomApiFp(configuration).createClassRoom(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a classroom
         * @param {number} classRoomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClassRoom(classRoomId: number, options?: any) {
            return ClassRoomApiFp(configuration).deleteClassRoom(classRoomId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a classroom by ID
         * @param {number} classRoomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClassRoomById(classRoomId: number, options?: any) {
            return ClassRoomApiFp(configuration).getClassRoomById(classRoomId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get classrooms
         * @param {GetClassRoomsFilter} filter 
         * @param {GetClassRoomsRequest} request 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClassrooms(filter: GetClassRoomsFilter, request: GetClassRoomsRequest, pageable: Pageable, options?: any) {
            return ClassRoomApiFp(configuration).getClassrooms(filter, request, pageable, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a classroom
         * @param {UpdateClassRoomRequest} body 
         * @param {number} classRoomId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClassRoom(body: UpdateClassRoomRequest, classRoomId: number, options?: any) {
            return ClassRoomApiFp(configuration).updateClassRoom(body, classRoomId, options)(fetch, basePath);
        },
    };
};

/**
 * ClassRoomApi - object-oriented interface
 * @export
 * @class ClassRoomApi
 * @extends {BaseAPI}
 */
export class ClassRoomApi extends BaseAPI {
    /**
     * 
     * @summary Create a classroom
     * @param {CreateClassRoomRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassRoomApi
     */
    public createClassRoom(body: CreateClassRoomRequest, options?: any) {
        return ClassRoomApiFp(this.configuration).createClassRoom(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete a classroom
     * @param {number} classRoomId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassRoomApi
     */
    public deleteClassRoom(classRoomId: number, options?: any) {
        return ClassRoomApiFp(this.configuration).deleteClassRoom(classRoomId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a classroom by ID
     * @param {number} classRoomId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassRoomApi
     */
    public getClassRoomById(classRoomId: number, options?: any) {
        return ClassRoomApiFp(this.configuration).getClassRoomById(classRoomId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get classrooms
     * @param {GetClassRoomsFilter} filter 
     * @param {GetClassRoomsRequest} request 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassRoomApi
     */
    public getClassrooms(filter: GetClassRoomsFilter, request: GetClassRoomsRequest, pageable: Pageable, options?: any) {
        return ClassRoomApiFp(this.configuration).getClassrooms(filter, request, pageable, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update a classroom
     * @param {UpdateClassRoomRequest} body 
     * @param {number} classRoomId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassRoomApi
     */
    public updateClassRoom(body: UpdateClassRoomRequest, classRoomId: number, options?: any) {
        return ClassRoomApiFp(this.configuration).updateClassRoom(body, classRoomId, options)(this.fetch, this.basePath);
    }

}
/**
 * RootApi - fetch parameter creator
 * @export
 */
export const RootApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        root(options: any = {}): FetchArgs {
            const localVarPath = `/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RootApi - functional programming interface
 * @export
 */
export const RootApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        root(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponseString> {
            const localVarFetchArgs = RootApiFetchParamCreator(configuration).root(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RootApi - factory interface
 * @export
 */
export const RootApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        root(options?: any) {
            return RootApiFp(configuration).root(options)(fetch, basePath);
        },
    };
};

/**
 * RootApi - object-oriented interface
 * @export
 * @class RootApi
 * @extends {BaseAPI}
 */
export class RootApi extends BaseAPI {
    /**
     * 
     * @summary Root
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RootApi
     */
    public root(options?: any) {
        return RootApiFp(this.configuration).root(options)(this.fetch, this.basePath);
    }

}
/**
 * ScheduleApi - fetch parameter creator
 * @export
 */
export const ScheduleApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a schedule
         * @param {CreateScheduleRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSchedule(body: CreateScheduleRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling createSchedule.');
            }
            const localVarPath = `/schedules`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateScheduleRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a schedule
         * @param {number} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSchedule(scheduleId: number, options: any = {}): FetchArgs {
            // verify required parameter 'scheduleId' is not null or undefined
            if (scheduleId === null || scheduleId === undefined) {
                throw new RequiredError('scheduleId', 'Required parameter scheduleId was null or undefined when calling deleteSchedule.');
            }
            const localVarPath = `/schedules/{scheduleId}`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a schedule by ID
         * @param {number} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScheduleById(scheduleId: number, options: any = {}): FetchArgs {
            // verify required parameter 'scheduleId' is not null or undefined
            if (scheduleId === null || scheduleId === undefined) {
                throw new RequiredError('scheduleId', 'Required parameter scheduleId was null or undefined when calling getScheduleById.');
            }
            const localVarPath = `/schedules/{scheduleId}`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a schedule
         * @param {UpdateScheduleRequest} body 
         * @param {number} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSchedule(body: UpdateScheduleRequest, scheduleId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling updateSchedule.');
            }
            // verify required parameter 'scheduleId' is not null or undefined
            if (scheduleId === null || scheduleId === undefined) {
                throw new RequiredError('scheduleId', 'Required parameter scheduleId was null or undefined when calling updateSchedule.');
            }
            const localVarPath = `/schedules/{scheduleId}`
                .replace(`{${"scheduleId"}}`, encodeURIComponent(String(scheduleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateScheduleRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScheduleApi - functional programming interface
 * @export
 */
export const ScheduleApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a schedule
         * @param {CreateScheduleRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSchedule(body: CreateScheduleRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponseScheduleDto> {
            const localVarFetchArgs = ScheduleApiFetchParamCreator(configuration).createSchedule(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete a schedule
         * @param {number} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSchedule(scheduleId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponseVoid> {
            const localVarFetchArgs = ScheduleApiFetchParamCreator(configuration).deleteSchedule(scheduleId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a schedule by ID
         * @param {number} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScheduleById(scheduleId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponseScheduleDto> {
            const localVarFetchArgs = ScheduleApiFetchParamCreator(configuration).getScheduleById(scheduleId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update a schedule
         * @param {UpdateScheduleRequest} body 
         * @param {number} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSchedule(body: UpdateScheduleRequest, scheduleId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponseScheduleDto> {
            const localVarFetchArgs = ScheduleApiFetchParamCreator(configuration).updateSchedule(body, scheduleId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ScheduleApi - factory interface
 * @export
 */
export const ScheduleApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create a schedule
         * @param {CreateScheduleRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSchedule(body: CreateScheduleRequest, options?: any) {
            return ScheduleApiFp(configuration).createSchedule(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a schedule
         * @param {number} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSchedule(scheduleId: number, options?: any) {
            return ScheduleApiFp(configuration).deleteSchedule(scheduleId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a schedule by ID
         * @param {number} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScheduleById(scheduleId: number, options?: any) {
            return ScheduleApiFp(configuration).getScheduleById(scheduleId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a schedule
         * @param {UpdateScheduleRequest} body 
         * @param {number} scheduleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSchedule(body: UpdateScheduleRequest, scheduleId: number, options?: any) {
            return ScheduleApiFp(configuration).updateSchedule(body, scheduleId, options)(fetch, basePath);
        },
    };
};

/**
 * ScheduleApi - object-oriented interface
 * @export
 * @class ScheduleApi
 * @extends {BaseAPI}
 */
export class ScheduleApi extends BaseAPI {
    /**
     * 
     * @summary Create a schedule
     * @param {CreateScheduleRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public createSchedule(body: CreateScheduleRequest, options?: any) {
        return ScheduleApiFp(this.configuration).createSchedule(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete a schedule
     * @param {number} scheduleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public deleteSchedule(scheduleId: number, options?: any) {
        return ScheduleApiFp(this.configuration).deleteSchedule(scheduleId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a schedule by ID
     * @param {number} scheduleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public getScheduleById(scheduleId: number, options?: any) {
        return ScheduleApiFp(this.configuration).getScheduleById(scheduleId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update a schedule
     * @param {UpdateScheduleRequest} body 
     * @param {number} scheduleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public updateSchedule(body: UpdateScheduleRequest, scheduleId: number, options?: any) {
        return ScheduleApiFp(this.configuration).updateSchedule(body, scheduleId, options)(this.fetch, this.basePath);
    }

}
/**
 * StudyMaterialApi - fetch parameter creator
 * @export
 */
export const StudyMaterialApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a study material
         * @param {string} [title] 
         * @param {number} [subjectId] 
         * @param {number} [teacherId] 
         * @param {Array<number>} [bookIds] 
         * @param {Array<Blob>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStudyMaterial(title?: string, subjectId?: number, teacherId?: number, bookIds?: Array<number>, files?: Array<Blob>, options: any = {}): FetchArgs {
            const localVarPath = `/study_materials`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication bearerAuth required

            if (title !== undefined) {
                localVarFormParams.set('title', title as any);
            }

            if (subjectId !== undefined) {
                localVarFormParams.set('subjectId', subjectId as any);
            }

            if (teacherId !== undefined) {
                localVarFormParams.set('teacherId', teacherId as any);
            }

            if (bookIds) {
                bookIds.forEach((element) => {
                    localVarFormParams.append('bookIds', element as any);
                })
            }

            if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a study material
         * @param {number} studyMaterialId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStudyMaterial(studyMaterialId: number, options: any = {}): FetchArgs {
            // verify required parameter 'studyMaterialId' is not null or undefined
            if (studyMaterialId === null || studyMaterialId === undefined) {
                throw new RequiredError('studyMaterialId', 'Required parameter studyMaterialId was null or undefined when calling deleteStudyMaterial.');
            }
            const localVarPath = `/study_materials/{studyMaterialId}`
                .replace(`{${"studyMaterialId"}}`, encodeURIComponent(String(studyMaterialId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a study material by ID
         * @param {number} studyMaterialId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyMaterial(studyMaterialId: number, options: any = {}): FetchArgs {
            // verify required parameter 'studyMaterialId' is not null or undefined
            if (studyMaterialId === null || studyMaterialId === undefined) {
                throw new RequiredError('studyMaterialId', 'Required parameter studyMaterialId was null or undefined when calling getStudyMaterial.');
            }
            const localVarPath = `/study_materials/{studyMaterialId}`
                .replace(`{${"studyMaterialId"}}`, encodeURIComponent(String(studyMaterialId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download a study material by file id
         * @param {number} studyMaterialId 
         * @param {number} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyMaterialFile(studyMaterialId: number, fileId: number, options: any = {}): FetchArgs {
            // verify required parameter 'studyMaterialId' is not null or undefined
            if (studyMaterialId === null || studyMaterialId === undefined) {
                throw new RequiredError('studyMaterialId', 'Required parameter studyMaterialId was null or undefined when calling getStudyMaterialFile.');
            }
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new RequiredError('fileId', 'Required parameter fileId was null or undefined when calling getStudyMaterialFile.');
            }
            const localVarPath = `/study_materials/{studyMaterialId}/files/{fileId}`
                .replace(`{${"studyMaterialId"}}`, encodeURIComponent(String(studyMaterialId)))
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a study material
         * @param {number} studyMaterialId 
         * @param {string} [title] 
         * @param {number} [subjectId] 
         * @param {number} [teacherId] 
         * @param {Array<number>} [bookIds] 
         * @param {Array<number>} [deletedFileIds] 
         * @param {Array<Blob>} [newFiles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStudyMaterial(studyMaterialId: number, title?: string, subjectId?: number, teacherId?: number, bookIds?: Array<number>, deletedFileIds?: Array<number>, newFiles?: Array<Blob>, options: any = {}): FetchArgs {
            // verify required parameter 'studyMaterialId' is not null or undefined
            if (studyMaterialId === null || studyMaterialId === undefined) {
                throw new RequiredError('studyMaterialId', 'Required parameter studyMaterialId was null or undefined when calling updateStudyMaterial.');
            }
            const localVarPath = `/study_materials/{studyMaterialId}`
                .replace(`{${"studyMaterialId"}}`, encodeURIComponent(String(studyMaterialId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication bearerAuth required

            if (title !== undefined) {
                localVarFormParams.set('title', title as any);
            }

            if (subjectId !== undefined) {
                localVarFormParams.set('subjectId', subjectId as any);
            }

            if (teacherId !== undefined) {
                localVarFormParams.set('teacherId', teacherId as any);
            }

            if (bookIds) {
                bookIds.forEach((element) => {
                    localVarFormParams.append('bookIds', element as any);
                })
            }

            if (deletedFileIds) {
                deletedFileIds.forEach((element) => {
                    localVarFormParams.append('deletedFileIds', element as any);
                })
            }

            if (newFiles) {
                newFiles.forEach((element) => {
                    localVarFormParams.append('newFiles', element as any);
                })
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StudyMaterialApi - functional programming interface
 * @export
 */
export const StudyMaterialApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a study material
         * @param {string} [title] 
         * @param {number} [subjectId] 
         * @param {number} [teacherId] 
         * @param {Array<number>} [bookIds] 
         * @param {Array<Blob>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStudyMaterial(title?: string, subjectId?: number, teacherId?: number, bookIds?: Array<number>, files?: Array<Blob>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponseStudyMaterialDto> {
            const localVarFetchArgs = StudyMaterialApiFetchParamCreator(configuration).createStudyMaterial(title, subjectId, teacherId, bookIds, files, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete a study material
         * @param {number} studyMaterialId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStudyMaterial(studyMaterialId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponseVoid> {
            const localVarFetchArgs = StudyMaterialApiFetchParamCreator(configuration).deleteStudyMaterial(studyMaterialId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a study material by ID
         * @param {number} studyMaterialId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyMaterial(studyMaterialId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponseStudyMaterialDto> {
            const localVarFetchArgs = StudyMaterialApiFetchParamCreator(configuration).getStudyMaterial(studyMaterialId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Download a study material by file id
         * @param {number} studyMaterialId 
         * @param {number} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyMaterialFile(studyMaterialId: number, fileId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = StudyMaterialApiFetchParamCreator(configuration).getStudyMaterialFile(studyMaterialId, fileId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update a study material
         * @param {number} studyMaterialId 
         * @param {string} [title] 
         * @param {number} [subjectId] 
         * @param {number} [teacherId] 
         * @param {Array<number>} [bookIds] 
         * @param {Array<number>} [deletedFileIds] 
         * @param {Array<Blob>} [newFiles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStudyMaterial(studyMaterialId: number, title?: string, subjectId?: number, teacherId?: number, bookIds?: Array<number>, deletedFileIds?: Array<number>, newFiles?: Array<Blob>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponseStudyMaterialDto> {
            const localVarFetchArgs = StudyMaterialApiFetchParamCreator(configuration).updateStudyMaterial(studyMaterialId, title, subjectId, teacherId, bookIds, deletedFileIds, newFiles, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StudyMaterialApi - factory interface
 * @export
 */
export const StudyMaterialApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create a study material
         * @param {string} [title] 
         * @param {number} [subjectId] 
         * @param {number} [teacherId] 
         * @param {Array<number>} [bookIds] 
         * @param {Array<Blob>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStudyMaterial(title?: string, subjectId?: number, teacherId?: number, bookIds?: Array<number>, files?: Array<Blob>, options?: any) {
            return StudyMaterialApiFp(configuration).createStudyMaterial(title, subjectId, teacherId, bookIds, files, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a study material
         * @param {number} studyMaterialId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStudyMaterial(studyMaterialId: number, options?: any) {
            return StudyMaterialApiFp(configuration).deleteStudyMaterial(studyMaterialId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a study material by ID
         * @param {number} studyMaterialId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyMaterial(studyMaterialId: number, options?: any) {
            return StudyMaterialApiFp(configuration).getStudyMaterial(studyMaterialId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Download a study material by file id
         * @param {number} studyMaterialId 
         * @param {number} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStudyMaterialFile(studyMaterialId: number, fileId: number, options?: any) {
            return StudyMaterialApiFp(configuration).getStudyMaterialFile(studyMaterialId, fileId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a study material
         * @param {number} studyMaterialId 
         * @param {string} [title] 
         * @param {number} [subjectId] 
         * @param {number} [teacherId] 
         * @param {Array<number>} [bookIds] 
         * @param {Array<number>} [deletedFileIds] 
         * @param {Array<Blob>} [newFiles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStudyMaterial(studyMaterialId: number, title?: string, subjectId?: number, teacherId?: number, bookIds?: Array<number>, deletedFileIds?: Array<number>, newFiles?: Array<Blob>, options?: any) {
            return StudyMaterialApiFp(configuration).updateStudyMaterial(studyMaterialId, title, subjectId, teacherId, bookIds, deletedFileIds, newFiles, options)(fetch, basePath);
        },
    };
};

/**
 * StudyMaterialApi - object-oriented interface
 * @export
 * @class StudyMaterialApi
 * @extends {BaseAPI}
 */
export class StudyMaterialApi extends BaseAPI {
    /**
     * 
     * @summary Create a study material
     * @param {string} [title] 
     * @param {number} [subjectId] 
     * @param {number} [teacherId] 
     * @param {Array<number>} [bookIds] 
     * @param {Array<Blob>} [files] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudyMaterialApi
     */
    public createStudyMaterial(title?: string, subjectId?: number, teacherId?: number, bookIds?: Array<number>, files?: Array<Blob>, options?: any) {
        return StudyMaterialApiFp(this.configuration).createStudyMaterial(title, subjectId, teacherId, bookIds, files, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete a study material
     * @param {number} studyMaterialId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudyMaterialApi
     */
    public deleteStudyMaterial(studyMaterialId: number, options?: any) {
        return StudyMaterialApiFp(this.configuration).deleteStudyMaterial(studyMaterialId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a study material by ID
     * @param {number} studyMaterialId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudyMaterialApi
     */
    public getStudyMaterial(studyMaterialId: number, options?: any) {
        return StudyMaterialApiFp(this.configuration).getStudyMaterial(studyMaterialId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Download a study material by file id
     * @param {number} studyMaterialId 
     * @param {number} fileId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudyMaterialApi
     */
    public getStudyMaterialFile(studyMaterialId: number, fileId: number, options?: any) {
        return StudyMaterialApiFp(this.configuration).getStudyMaterialFile(studyMaterialId, fileId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update a study material
     * @param {number} studyMaterialId 
     * @param {string} [title] 
     * @param {number} [subjectId] 
     * @param {number} [teacherId] 
     * @param {Array<number>} [bookIds] 
     * @param {Array<number>} [deletedFileIds] 
     * @param {Array<Blob>} [newFiles] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StudyMaterialApi
     */
    public updateStudyMaterial(studyMaterialId: number, title?: string, subjectId?: number, teacherId?: number, bookIds?: Array<number>, deletedFileIds?: Array<number>, newFiles?: Array<Blob>, options?: any) {
        return StudyMaterialApiFp(this.configuration).updateStudyMaterial(studyMaterialId, title, subjectId, teacherId, bookIds, deletedFileIds, newFiles, options)(this.fetch, this.basePath);
    }

}
/**
 * SubjectApi - fetch parameter creator
 * @export
 */
export const SubjectApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a subject
         * @param {CreateSubjectRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubject(body: CreateSubjectRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling createSubject.');
            }
            const localVarPath = `/subjects/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateSubjectRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a subject
         * @param {number} subjectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubject(subjectId: number, options: any = {}): FetchArgs {
            // verify required parameter 'subjectId' is not null or undefined
            if (subjectId === null || subjectId === undefined) {
                throw new RequiredError('subjectId', 'Required parameter subjectId was null or undefined when calling deleteSubject.');
            }
            const localVarPath = `/subjects/{subjectId}`
                .replace(`{${"subjectId"}}`, encodeURIComponent(String(subjectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a subject by ID
         * @param {number} subjectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubjectById(subjectId: number, options: any = {}): FetchArgs {
            // verify required parameter 'subjectId' is not null or undefined
            if (subjectId === null || subjectId === undefined) {
                throw new RequiredError('subjectId', 'Required parameter subjectId was null or undefined when calling getSubjectById.');
            }
            const localVarPath = `/subjects/{subjectId}`
                .replace(`{${"subjectId"}}`, encodeURIComponent(String(subjectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get subjects
         * @param {GetSubjectsFilter} getSubjectsFilter 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubjects(getSubjectsFilter: GetSubjectsFilter, pageable: Pageable, options: any = {}): FetchArgs {
            // verify required parameter 'getSubjectsFilter' is not null or undefined
            if (getSubjectsFilter === null || getSubjectsFilter === undefined) {
                throw new RequiredError('getSubjectsFilter', 'Required parameter getSubjectsFilter was null or undefined when calling getSubjects.');
            }
            // verify required parameter 'pageable' is not null or undefined
            if (pageable === null || pageable === undefined) {
                throw new RequiredError('pageable', 'Required parameter pageable was null or undefined when calling getSubjects.');
            }
            const localVarPath = `/subjects`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (getSubjectsFilter !== undefined) {
                localVarQueryParameter['getSubjectsFilter'] = getSubjectsFilter;
            }

            if (pageable !== undefined) {
                localVarQueryParameter['pageable'] = pageable;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a subject
         * @param {UpdateSubjectRequest} body 
         * @param {number} subjectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubject(body: UpdateSubjectRequest, subjectId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling updateSubject.');
            }
            // verify required parameter 'subjectId' is not null or undefined
            if (subjectId === null || subjectId === undefined) {
                throw new RequiredError('subjectId', 'Required parameter subjectId was null or undefined when calling updateSubject.');
            }
            const localVarPath = `/subjects/{subjectId}`
                .replace(`{${"subjectId"}}`, encodeURIComponent(String(subjectId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateSubjectRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubjectApi - functional programming interface
 * @export
 */
export const SubjectApiFp = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a subject
         * @param {CreateSubjectRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubject(body: CreateSubjectRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponseSubjectDto> {
            const localVarFetchArgs = SubjectApiFetchParamCreator(configuration).createSubject(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete a subject
         * @param {number} subjectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubject(subjectId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponseVoid> {
            const localVarFetchArgs = SubjectApiFetchParamCreator(configuration).deleteSubject(subjectId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a subject by ID
         * @param {number} subjectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubjectById(subjectId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponseSubjectDto> {
            const localVarFetchArgs = SubjectApiFetchParamCreator(configuration).getSubjectById(subjectId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get subjects
         * @param {GetSubjectsFilter} getSubjectsFilter 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubjects(getSubjectsFilter: GetSubjectsFilter, pageable: Pageable, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponsePageInfoResponseSubjectDto> {
            const localVarFetchArgs = SubjectApiFetchParamCreator(configuration).getSubjects(getSubjectsFilter, pageable, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update a subject
         * @param {UpdateSubjectRequest} body 
         * @param {number} subjectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubject(body: UpdateSubjectRequest, subjectId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponseSubjectDto> {
            const localVarFetchArgs = SubjectApiFetchParamCreator(configuration).updateSubject(body, subjectId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SubjectApi - factory interface
 * @export
 */
export const SubjectApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create a subject
         * @param {CreateSubjectRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubject(body: CreateSubjectRequest, options?: any) {
            return SubjectApiFp(configuration).createSubject(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a subject
         * @param {number} subjectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubject(subjectId: number, options?: any) {
            return SubjectApiFp(configuration).deleteSubject(subjectId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a subject by ID
         * @param {number} subjectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubjectById(subjectId: number, options?: any) {
            return SubjectApiFp(configuration).getSubjectById(subjectId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get subjects
         * @param {GetSubjectsFilter} getSubjectsFilter 
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubjects(getSubjectsFilter: GetSubjectsFilter, pageable: Pageable, options?: any) {
            return SubjectApiFp(configuration).getSubjects(getSubjectsFilter, pageable, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a subject
         * @param {UpdateSubjectRequest} body 
         * @param {number} subjectId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubject(body: UpdateSubjectRequest, subjectId: number, options?: any) {
            return SubjectApiFp(configuration).updateSubject(body, subjectId, options)(fetch, basePath);
        },
    };
};

/**
 * SubjectApi - object-oriented interface
 * @export
 * @class SubjectApi
 * @extends {BaseAPI}
 */
export class SubjectApi extends BaseAPI {
    /**
     * 
     * @summary Create a subject
     * @param {CreateSubjectRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubjectApi
     */
    public createSubject(body: CreateSubjectRequest, options?: any) {
        return SubjectApiFp(this.configuration).createSubject(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete a subject
     * @param {number} subjectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubjectApi
     */
    public deleteSubject(subjectId: number, options?: any) {
        return SubjectApiFp(this.configuration).deleteSubject(subjectId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a subject by ID
     * @param {number} subjectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubjectApi
     */
    public getSubjectById(subjectId: number, options?: any) {
        return SubjectApiFp(this.configuration).getSubjectById(subjectId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get subjects
     * @param {GetSubjectsFilter} getSubjectsFilter 
     * @param {Pageable} pageable 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubjectApi
     */
    public getSubjects(getSubjectsFilter: GetSubjectsFilter, pageable: Pageable, options?: any) {
        return SubjectApiFp(this.configuration).getSubjects(getSubjectsFilter, pageable, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update a subject
     * @param {UpdateSubjectRequest} body 
     * @param {number} subjectId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubjectApi
     */
    public updateSubject(body: UpdateSubjectRequest, subjectId: number, options?: any) {
        return SubjectApiFp(this.configuration).updateSubject(body, subjectId, options)(this.fetch, this.basePath);
    }

}
